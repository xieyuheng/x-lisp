;;; Input

(define (main) (assert-equal [:x 'a :y 'b] '(:x a :y b)))

;;; ShrinkPass

(define (main)
  (assert-equal
    (let ((tael (make-list)))
      (begin
        (record-put! 'x 'a tael)
        (begin (record-put! 'y 'b tael) tael)))
    (let ((tael (make-list)))
      (begin
        (record-put! 'x 'a tael)
        (begin (record-put! 'y 'b tael) tael)))))

;;; UniquifyPass

(define (main)
  (assert-equal
    (let ((tael₁ (make-list)))
      (begin
        (record-put! 'x 'a tael₁)
        (begin (record-put! 'y 'b tael₁) tael₁)))
    (let ((tael₁ (make-list)))
      (begin
        (record-put! 'x 'a tael₁)
        (begin (record-put! 'y 'b tael₁) tael₁)))))

;;; RevealGlobalPass

(define (main)
  ((@primitive assert-equal 2)
   (let ((tael₁ ((@primitive make-list 0))))
     (begin
       ((@primitive record-put! 3) 'x 'a tael₁)
       (begin ((@primitive record-put! 3) 'y 'b tael₁) tael₁)))
   (let ((tael₁ ((@primitive make-list 0))))
     (begin
       ((@primitive record-put! 3) 'x 'a tael₁)
       (begin ((@primitive record-put! 3) 'y 'b tael₁) tael₁)))))

;;; LiftLambdaPass

(define (main)
  ((@primitive assert-equal 2)
   (let ((tael₁ ((@primitive make-list 0))))
     (begin
       ((@primitive record-put! 3) 'x 'a tael₁)
       (begin ((@primitive record-put! 3) 'y 'b tael₁) tael₁)))
   (let ((tael₁ ((@primitive make-list 0))))
     (begin
       ((@primitive record-put! 3) 'x 'a tael₁)
       (begin ((@primitive record-put! 3) 'y 'b tael₁) tael₁)))))

;;; UnnestOperandPass

(define (main)
  (let ((tael₁ ((@primitive make-list 0))))
    (begin
      ((@primitive record-put! 3) 'x 'a tael₁)
      (begin
        ((@primitive record-put! 3) 'y 'b tael₁)
        (let ((tael₁ ((@primitive make-list 0))))
          (begin
            ((@primitive record-put! 3) 'x 'a tael₁)
            (begin
              ((@primitive record-put! 3) 'y 'b tael₁)
              ((@primitive assert-equal 2) tael₁ tael₁))))))))

