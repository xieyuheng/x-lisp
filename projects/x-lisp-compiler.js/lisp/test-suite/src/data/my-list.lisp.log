;;; Input

(export
  my-list?
  nil
  nil?
  li
  li?
  li-head
  li-tail
  li-put-head
  li-put-tail
  li-put-head!
  li-put-tail!)

(define (my-list? E value)
  (or (nil? value)
      (and (li? value)
           (E (li-head value))
           ((my-list? E) (li-tail value)))))

(define nil #nil)

(define (nil? value) (equal? value #nil))

(define (li head tail) [#li head tail])

(define (li? value)
  (and (any-list? value)
       (equal? (list-length value) 3)
       (equal? (list-head value) #li)))

(define (li-head target) (list-get 1 target))

(define (li-tail target) (list-get 2 target))

(define (li-put-head value target)
  (list-put 1 value target))

(define (li-put-tail value target)
  (list-put 2 value target))

(define (li-put-head! value target)
  (list-put! 1 value target))

(define (li-put-tail! value target)
  (list-put! 2 value target))

;;; ShrinkPass

(export
  my-list?
  nil
  nil?
  li
  li?
  li-head
  li-tail
  li-put-head
  li-put-tail
  li-put-head!
  li-put-tail!)

(define (my-list? E value)
  (if (nil? value)
    #t
    (if (li? value)
      (if (E (li-head value))
        ((my-list? E) (li-tail value))
        #f)
      #f)))

(define nil #nil)

(define (nil? value) (equal? value #nil))

(define (li head tail)
  (let ((tael (make-list)))
    (begin
      (list-push! #li tael)
      (list-push! head tael)
      (list-push! tail tael)
      tael)))

(define (li? value)
  (if (any-list? value)
    (if (equal? (list-length value) 3)
      (equal? (list-head value) #li)
      #f)
    #f))

(define (li-head target) (list-get 1 target))

(define (li-tail target) (list-get 2 target))

(define (li-put-head value target)
  (list-put 1 value target))

(define (li-put-tail value target)
  (list-put 2 value target))

(define (li-put-head! value target)
  (list-put! 1 value target))

(define (li-put-tail! value target)
  (list-put! 2 value target))

;;; UniquifyPass

(export
  my-list?
  nil
  nil?
  li
  li?
  li-head
  li-tail
  li-put-head
  li-put-tail
  li-put-head!
  li-put-tail!)

(define (my-list? E value)
  (if (nil? value)
    #t
    (if (li? value)
      (if (E (li-head value))
        ((my-list? E) (li-tail value))
        #f)
      #f)))

(define nil #nil)

(define (nil? value) (equal? value #nil))

(define (li head tail)
  (let ((tael₁ (make-list)))
    (begin
      (list-push! #li tael₁)
      (list-push! head tael₁)
      (list-push! tail tael₁)
      tael₁)))

(define (li? value)
  (if (any-list? value)
    (if (equal? (list-length value) 3)
      (equal? (list-head value) #li)
      #f)
    #f))

(define (li-head target) (list-get 1 target))

(define (li-tail target) (list-get 2 target))

(define (li-put-head value target)
  (list-put 1 value target))

(define (li-put-tail value target)
  (list-put 2 value target))

(define (li-put-head! value target)
  (list-put! 1 value target))

(define (li-put-tail! value target)
  (list-put! 2 value target))

;;; RevealGlobalPass

(export
  my-list?
  nil
  nil?
  li
  li?
  li-head
  li-tail
  li-put-head
  li-put-tail
  li-put-head!
  li-put-tail!)

(define (my-list? E value)
  (if (nil? value)
    #t
    (if (li? value)
      (if (E (li-head value))
        ((my-list? E) (li-tail value))
        #f)
      #f)))

(define nil #nil)

(define (nil? value) (equal? value #nil))

(define (li head tail)
  (let ((tael₁ (make-list)))
    (begin
      (list-push! #li tael₁)
      (list-push! head tael₁)
      (list-push! tail tael₁)
      tael₁)))

(define (li? value)
  (if (any-list? value)
    (if (equal? (list-length value) 3)
      (equal? (list-head value) #li)
      #f)
    #f))

(define (li-head target) (list-get 1 target))

(define (li-tail target) (list-get 2 target))

(define (li-put-head value target)
  (list-put 1 value target))

(define (li-put-tail value target)
  (list-put 2 value target))

(define (li-put-head! value target)
  (list-put! 1 value target))

(define (li-put-tail! value target)
  (list-put! 2 value target))

;;; LiftLambdaPass

(export
  my-list?
  nil
  nil?
  li
  li?
  li-head
  li-tail
  li-put-head
  li-put-tail
  li-put-head!
  li-put-tail!)

(define (my-list? E value)
  (if (nil? value)
    #t
    (if (li? value)
      (if (E (li-head value))
        ((my-list? E) (li-tail value))
        #f)
      #f)))

(define nil #nil)

(define (nil? value) (equal? value #nil))

(define (li head tail)
  (let ((tael₁ (make-list)))
    (begin
      (list-push! #li tael₁)
      (list-push! head tael₁)
      (list-push! tail tael₁)
      tael₁)))

(define (li? value)
  (if (any-list? value)
    (if (equal? (list-length value) 3)
      (equal? (list-head value) #li)
      #f)
    #f))

(define (li-head target) (list-get 1 target))

(define (li-tail target) (list-get 2 target))

(define (li-put-head value target)
  (list-put 1 value target))

(define (li-put-tail value target)
  (list-put 2 value target))

(define (li-put-head! value target)
  (list-put! 1 value target))

(define (li-put-tail! value target)
  (list-put! 2 value target))

;;; UnnestOperandPass

(export
  my-list?
  nil
  nil?
  li
  li?
  li-head
  li-tail
  li-put-head
  li-put-tail
  li-put-head!
  li-put-tail!)

(define (my-list? E value)
  (if (nil? value)
    #t
    (if (li? value)
      (if (let ((_₁ (li-head value))) (E _₁))
        (let ((_₂ (my-list? E)))
          (let ((_₃ (li-tail value))) (_₂ _₃)))
        #f)
      #f)))

(define nil #nil)

(define (nil? value) (equal? value #nil))

(define (li head tail)
  (let ((tael₁ (make-list)))
    (begin
      (list-push! #li tael₁)
      (list-push! head tael₁)
      (list-push! tail tael₁)
      tael₁)))

(define (li? value)
  (if (any-list? value)
    (if (let ((_₁ (list-length value))) (equal? _₁ 3))
      (let ((_₂ (list-head value))) (equal? _₂ #li))
      #f)
    #f))

(define (li-head target) (list-get 1 target))

(define (li-tail target) (list-get 2 target))

(define (li-put-head value target)
  (list-put 1 value target))

(define (li-put-tail value target)
  (list-put 2 value target))

(define (li-put-head! value target)
  (list-put! 1 value target))

(define (li-put-tail! value target)
  (list-put! 2 value target))

