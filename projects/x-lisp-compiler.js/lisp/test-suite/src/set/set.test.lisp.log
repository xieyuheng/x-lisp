;;; Input

(define (main) (assert-equal {1 2 3} {1 2 3}))

;;; ShrinkPass

(define (main)
  (assert-equal
    (let ((set (make-set)))
      (begin
        (set-add! 1 set)
        (begin
          (set-add! 2 set)
          (begin (set-add! 3 set) set))))
    (let ((set (make-set)))
      (begin
        (set-add! 1 set)
        (begin
          (set-add! 2 set)
          (begin (set-add! 3 set) set))))))

;;; UniquifyPass

(define (main)
  (assert-equal
    (let ((set₁ (make-set)))
      (begin
        (set-add! 1 set₁)
        (begin
          (set-add! 2 set₁)
          (begin (set-add! 3 set₁) set₁))))
    (let ((set₁ (make-set)))
      (begin
        (set-add! 1 set₁)
        (begin
          (set-add! 2 set₁)
          (begin (set-add! 3 set₁) set₁))))))

;;; RevealGlobalPass

(define (main)
  (assert-equal
    (let ((set₁ (make-set)))
      (begin
        (set-add! 1 set₁)
        (begin
          (set-add! 2 set₁)
          (begin (set-add! 3 set₁) set₁))))
    (let ((set₁ (make-set)))
      (begin
        (set-add! 1 set₁)
        (begin
          (set-add! 2 set₁)
          (begin (set-add! 3 set₁) set₁))))))

;;; LiftLambdaPass

(define (main)
  (assert-equal
    (let ((set₁ (make-set)))
      (begin
        (set-add! 1 set₁)
        (begin
          (set-add! 2 set₁)
          (begin (set-add! 3 set₁) set₁))))
    (let ((set₁ (make-set)))
      (begin
        (set-add! 1 set₁)
        (begin
          (set-add! 2 set₁)
          (begin (set-add! 3 set₁) set₁))))))

;;; UnnestOperandPass

(define (main)
  (let ((set₁ (make-set)))
    (begin
      (set-add! 1 set₁)
      (begin
        (set-add! 2 set₁)
        (begin
          (set-add! 3 set₁)
          (let ((set₁ (make-set)))
            (begin
              (set-add! 1 set₁)
              (begin
                (set-add! 2 set₁)
                (begin
                  (set-add! 3 set₁)
                  (assert-equal set₁ set₁))))))))))

