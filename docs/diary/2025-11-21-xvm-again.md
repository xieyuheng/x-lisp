---
title: xvm-again
date: 2025-11-21
---

# why?

我决定用 VM 来实现 x-lisp，
因为对于动态类型语言而言，
GC 相关的问题太复杂了。

对于之后要实现的静态类型语言再实现编译器，比如 meta-lisp。

或者更合适地，是对于不需要 GC 的语言来实现编译器，
比如 system-lisp 和 linear-lisp。

[2025-11-23]
现在还不确定要放弃编译到 native code。
xvm 作为备选方案。
再继续调研一下。

# 行动

新的任务大概是：

- port x-sexp.js to runtime。

- port basic-lisp to runtime。

  - 保持现在的极简 instruction，
    对于 call 指令和某些 primitive function 做 inline 优化（比如 iadd），
    basic-lisp 的解释器要能写成一个简单的，
    有 switch 和很多 case 的 C 函数。

- 还是需要 GC，只不过这次 root scanning 问题简单多了。

但是可能不能直接实现 basic-lisp 的 vm。
因为对于底层 vm 或者 native 汇编来说，
call 和 assign 应该是两个指令。
而 basic-lisp 中 call 和 assign 到 dest 是一个指令。

也就是说：

- 要么在 c 的 byte code 解释器中拆分指令；
- 要么实现一个 basic-lisp 到 vm 的 instruction selection。

我想可能后者更合理一些。

可能要回到 xvm 和 xasm 以及 xrom 或 xexe 的设计。

# xvm

需求：

- 我需要 vm 因为 basic-lisp 的 call 指令是带有 dest 变量的，这与 vm 是有差别的。
- 我不需要指令集编码，因为我不需要稳定的二进制接口。
- 我不需要类 forth 的栈 vm，而是需要寄存器 vm，
  因为 basic-lisp 的函数有很多局部变量。

前面提到，把带有 GC 的纯动态类型语言，编译到 native code，不是很合理。
类似的，为带有 tag 的语言实现 instruction encoding 也不是很合理。
tag encoding 应该在软件层次进行。

行动：

- 用 c 实现 xvm 的模拟器（类似 inet-lisp 的 worker）。
- 用 c 实现 xvm.machine 的解释器（lisp 语法）。
- 编译出来 xvm.machine 文件，然后用 xvm 解释执行。

看之前 xvm 和 x-forth 的笔记，
发现很多设计上的问题都是因为语言没有分层。
现在的分层是：

- x-lisp -- 负责语言的功能
- basic-lisp -- 负责优化
- machine-lisp -- 负责具体执行

目前的计划只是解释 xvm.machine 文件，
之后如果有了稳定的 byte code 编码，
也可以考虑编译到 xrom 或 xexe。

现在 machine-lisp 真的有用了，
因为有 x86.machine 和 xvm.machine。
