---
title: why tael
date: 2025-09-16
---

# 动机

在想要增加 set 的 literal 语法时，
我对 tael 的设计产生的动摇，
现在重新回顾一下 tael 的设计起源。

（1）tael 是 list with attribute。
这一点的「合理性」来源于 XML 的 element + attribute 语义。
也就是说 tael 是可以看制作是 XML 的扩展，其中 tag 可以是任意 node。

（2）tael 的语法处理的「合理性」来源于对 quote 的类比：

- `'symbol` 被解析为 `(quote symbol)`
- `[a b c]` 被解析为 `(tael a b c)`

（3）tael 的用处之一是给语法关键词加可选部分，比如 `(class)` 的 `:inherit`。

（4）tael 的用处之二是将 attribute 作为 meta data 来保存 parse 时候的 span，
但是这种设计证明是错误的，样做是行不通的。

（5）tael 的设计灵感直接来自与之对应的 structural type 表达式 tau。
如果 tael 要被分离为两种数据 list 和 record，
那么 tau 也要被分离为两种类型表达式。

# 问题

其中（2）是关于语法的。
其后果是我没有像 clojure 一样区分 list 和 array，
单一的 collection 类型简化了语言，
这个设计来源 shen-lang 对 `[]` 的用法。

但是这在想要加入 set 的 literal 语法时产生了问题，
因为如果 `[1 2 3]` 被转化为了 `(tael 1 2 3)`，
读入 sexp 的时候，是没法区分 list 和 array 的。

那么按照这样的设计 `{1 2 3}` 也应该被转化为 `(@set 1 2 3)`，
届时 `(tael 1 2 3)` 可能也应写作 `(@tael 1 2 3)`，
`(quote symbol)` 也应写作 `(@quote symbol)`。

其中（1）是关于语义的。
在 eoc 目前的代码里，
可以发现我几乎没有用到 list with attribute，
都是只用 list 或者只用 record。

这是最令我担忧的，
因为所设计的 feature 没被用到，
证明设计是有问题的。

# 方案

首先语言带有 set 是比较重要的，
因为这能鼓励程序员多用正确的数据类型，
而不是经常用 list 来模拟 set。

这么说，是不是也因该区分 list 和 array 呢？

思考 tael 的代替方案：

（A）clojure 的设计，区分 `list array record set` 四种 literal。

（B）保守的设计，去掉所有语法糖一类的 literal 语法。
明显地用 `(@list) (@array) (@record) (@set)` 来表示 literal。
这种设计是最 scalable 的，并且可以推迟引入 `(@array)`。

但是关于是否融合 `(@list)` 与 `(@record)` 还是需要选择。
如果融合，可以用 `(@tael)`。

（C）放弃一致性，保持现在 tael 的设计，
把 set literal 作为一个 x-data 的数据类型加到 sexp 中。

尽管 set 已经是 X-data 的一部分了，
但是，reader 读到 `{a b c}` 的时候，
也就是 eval `'{a b c}` 的时候，
还是有必要转化为 `['@set 'a 'b 'c]`，
而不能是 `{'a 'b 'c}`。

因为如果 reader 读到 `{(random-dice) (random-dice) (random-dice)}`，
并且直接处理为 set 就是 `{['random-dice]}`，
这显然不是想要的结果。

也就是说 reader 所读到的 sexp 不会包含 set 只能包含 tael，
这种不一致性也让人担忧。
