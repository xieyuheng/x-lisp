---
title: why tael
date: 2025-09-16
---

在想要增加 set 的 literal 语法时，
我对 tael 的设计产生的动摇，
现在重新回顾一下 tael 的设计起源。

- （1）tael 是 list with attribute。
  这一点的「合理性」来源于 XML 的 element + attribute 语义。
  也就是说 tael 是可以看制作是 XML 的扩展，其中 tag 可以是任意 node。

- （2）tael 的语法处理的「合理性」来源于对 quote 的类比：

  - `'symbol` 被解析为 `(quote symbol)`
  - `[a b c]` 被解析为 `(tael a b c)`

- （3）tael 的用处之一是给语法关键词加可选部分，比如 `(class)` 的 `:inherit`。

- （4）tael 的用处之二是将 attribute 作为 meta data 来保存 parse 时候的 span，
  但是这种设计证明是错误的，样做是行不通的。

- （5）tael 的设计灵感直接来自与之对应的 structural type 表达式 tau。
  如果 tael 要被分离为两种数据 list 和 record，
  那么 tau 也要被分离为两种类型表达式。


其中（2）是关于语法的，
其后果是我没有像 clojure 一样区分 list 和 array，
单一的 collection 类型简化了语言。
但是这在想要加入 set 的 literal 语法时产生了问题，
因为按照这样的设计 `{1 2 3}` 也应该被转化为 `(literal-set 1 2 3)`。
读入 sexp 的时候，是没法区分 list 和 array 的，也就没法区分 set。

其中（1）是关于语义的，
我可以发现这种融合的语义我并没有用到，
在 eoc 目前的代码里，几乎没有用到 list with attribute 的情况，
都是只用 list 或者只用 record。
